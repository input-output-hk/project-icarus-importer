module Pos.ImporterDBConsistency.ConsistencyChecker
  (
    externalConsistencyFromBlk
  , externalConsistencyRandom
  , internalConsistencyCheck
  , externalConsistencyWithTxRange
  ) where

import           Universum

import           Data.List (tail)
import           System.Wlog (logInfo)

import qualified Pos.BlockchainImporter.Tables.TxsTable as TxsT (TxRecord)
import           Pos.Core (BlockCount (..), HasPrevBlock (prevBlockL), HasProtocolConstants,
                           HeaderHash, blkSecurityParam, headerHash)
import           Pos.DB (getHeader, getTipHeader)
import           Pos.GState.BlockExtra (resolveForwardLink)
import           Pos.ImporterDBConsistency.Properties
import           Pos.ImporterDBConsistency.Utils
import           Pos.Txp (Tx)

----------------------------------------------------------------------------
-- Checks
----------------------------------------------------------------------------

{-
  Check consistency with the key-value db of a node up-to-date.
  Objective: Test consistency of the postgresdb generated after running full import,
             with the one generated in a Cardano node.
  Requires: Having the postgresdb also up-to-date
    - Checks that the same best block is in both the node and postgresdb
    - Checks that utxo from node are stored in postgresdb
    - Checks that tx in node from all blocks starting from a given one are stored postgresdb
-}
externalConsistencyFromBlk :: ConsistencyCheckerEnv m => HeaderHash -> m Bool
externalConsistencyFromBlk blkHashes = do
  validBestBlock <- consistentBestBlock
  validUtxos <- consistentUtxo
  validTxsHistory <- allTxsStartingFromBlk txRowExists blkHashes
  pure $ validBestBlock && validTxsHistory && validUtxos

{-
  Check consistency with the key-value db of a node up-to-date.
  Objective: Test consistency of the postgresdb generated after running full import,
             with the one generated in a Cardano node.
  Requires: Having the postgresdb also up-to-date
    - Checks that the same best block is in both the node and postgresdb
    - Checks that utxo from node are stored in postgresdb
    - Checks that tx in node from random blocks are stored postgresdb
        The random blocks to check are received as a parameter
-}
-- FIXME: Log how many txs where found
externalConsistencyRandom :: ConsistencyCheckerEnv m => [HeaderHash] -> m Bool
externalConsistencyRandom blkHashes = do
  validBestBlock <- consistentBestBlock
  validTxsHistory <- allTxsFromManyBlksFullfilProp txRowExists blkHashes
  validUtxos <- consistentUtxo
  pure $ validBestBlock && validTxsHistory && validUtxos

{-
  Check consistency with the key-value db generated by the importer
  Objective: Test internal consistency of the importer, mainly when stopping
             it during the chain importing process.
    - Checks that utxo from importer are stored in postgresdb
    - Checks that txs in importer from (bestblock-blkRangeSize, bestblock]
      are stored in postgresdb
    - Check txs_addresses table consistency (with txs table)
    - Check best block consistency with tip block in node
 -}
internalConsistencyCheck :: ConsistencyCheckerEnv m => m Bool
internalConsistencyCheck = do
  lastNBlocks <- getLastNBlkHashes blkRangeSize
  validLastNBlksTxs <- allTxsFromManyBlksFullfilProp txRowExists lastNBlocks
  validUtxos <- consistentUtxo
  validTxAddr <- internalConsistentTxAddr
  validBestBlock <- consistentBestBlock
  pure $ validLastNBlksTxs && validUtxos && validTxAddr && validBestBlock

{-
  Check consistency of the latest blocks with the key-value db of an up-to-date node
  Objective: Test consistency of the previous and future txs (from the point of the importer),
             with the one's stored in a Cardano node
    - Checks that tx in node from (block-blkRangeSize, block] are stored in postgresdb
    - Checks that tx in node from (block, block+blkRangeSize) are not stored in postgresdb
-}
externalConsistencyWithTxRange :: ConsistencyCheckerEnv m => HeaderHash -> m Bool
externalConsistencyWithTxRange pgTipHash = do
  prevNBlock <- getPrevNBlkHashesFromHash blkRangeSize pgTipHash
  nextNBlock <- getNextNBlkHashesFromHash blkRangeSize pgTipHash
  logInfo "Checking txs previous blocks exist"
  validPrevNBlocks <- allTxsFromManyBlksFullfilProp txRowExists prevNBlock
  logInfo "Checking txs next blocks don't exist"
  validNextNBlocks <- allTxsFromManyBlksFullfilProp (const . isNothing) (tail nextNBlock)
  pure $ validPrevNBlocks && validNextNBlocks


----------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------

getLastNBlkHashes :: ConsistencyCheckerEnv m => Int -> m [HeaderHash]
getLastNBlkHashes numBlks = do
  tipHeader <- getTipHeader
  let tipHash = headerHash tipHeader
  getPrevNBlkHashesFromHash numBlks tipHash

getPrevNBlkHashesFromHash :: ConsistencyCheckerEnv m => Int -> HeaderHash -> m [HeaderHash]
getPrevNBlkHashesFromHash n initialHash = if n <= 0 then pure [] else
  maybeT (getHeader initialHash) (pure []) $ \initialHeader -> do
      let prevBlockHash = initialHeader ^. prevBlockL
      (initialHash:) <$> getPrevNBlkHashesFromHash (n - 1) prevBlockHash

getNextNBlkHashesFromHash :: ConsistencyCheckerEnv m => Int -> HeaderHash -> m [HeaderHash]
getNextNBlkHashesFromHash n initialHash = if n <= 0 then pure [] else
  maybeT (getHeader initialHash) (pure []) $ \initialHeader ->
      maybeT (resolveForwardLink initialHeader) (pure [initialHash]) $ \nextHeaderHash -> do
          hashesFromNext <- getNextNBlkHashesFromHash (n - 1) nextHeaderHash
          pure $ initialHash : hashesFromNext

-- blkRangeSize selected to be 'k' (number of blocks rollbacked on new epoch) + 10
blkRangeSize :: HasProtocolConstants => Int
blkRangeSize = (fromIntegral $ getBlockCount $ blkSecurityParam) + 10

--FIXME: Maybe use getTxOut to compare txs?
txRowExists :: Maybe TxsT.TxRecord -> Tx -> Bool
txRowExists maybeTxRow _ = isJust maybeTxRow
